#### 一、汇编实现 if else（注意：压栈可实现当前代码中断执行，可使用汇编工具 /tools/Mars4_5.jar 测试汇编代码）
```bash
if(i == j) {
    f = i + j
}else {
    f = i - j
}
-------------------汇编实现------------------------
# 寄存器3的值等于寄存器4的值，则往下走，否则跳到ELSE指令块
bne $r3,$r4,ELSE
# 将寄存器3和寄存器4的值相加放到寄存器5
add $r5,$r3,$4
# 指令到此结束
j EXIT
# ELSE 指令块
ELSE:
# 将寄存器3的值减去寄存器4的值，然后将结果放到寄存器5
sub $r5,$r3,$r4
# 指令到此结束
EXIT:
```

#### 二、汇编实现 for 循环（注意：压栈可实现当前代码中断执行，可使用汇编工具 /tools/Mars4_5.jar 测试汇编代码）
```bash
sum = 0
for(i = 0;i < 100;i++) {
    sum += i
}

-------------------汇编实现------------------------
# sum=0（将寄存器zero的值与0相加，最后将结果放到寄存器3（注意：$zero 表示一个始终存在的寄存器zero，它的值就是0））
addi $s3,$zero,0
# i=0（将寄存器zero的值与0相加，最后将结果放到寄存器4（注意：$zero 表示一个始终存在的寄存器zero，它的值就是0））
addi $s4,$zero,0
# 定义常数100（将寄存器zero的值与100相加，最后将结果放到寄存器5（注意：$zero 表示一个始终存在的寄存器zero，它的值就是0））
addi $s5,$zero,100
# 循环执行块开始位置
LOOP:
# 寄存器4和寄存器5的值相等，则调到EXIT语句块，否则往下走
beq $s4,$s5,EXIT
# sum += i（将寄存器4和寄存器3的值相加，最后将结果放又到寄存器3）
add $s3,$s4,$s3
# i++（将寄存器4的值加1，最后将结果又放到寄存器4）
addi $s4,$s4,1
# 循环执行块结束位置
j LOOP
# EXIT语句块（注意：这个指令块，没有指令代码，其实就是跳出循环）
EXIT:
```

#### 三、汇编实现函数（注意：压栈可实现当前代码中断执行，可使用汇编工具 /tools/Mars4_5.jar 测试汇编代码）
```bash
fn fact(int n){
    if(n == 0){
        return 1
    }
    return fact(n - 1) * n
}

-------------------汇编实现函数定义fact(5) -----------------------
# 递归函数
# 修改栈寄存器sp的值（将寄存器0的值加0x10010080之后放到栈寄存器sp里面，注意：$0 表示一个始终存在的寄存器zero，它的值就是0）
addiu $sp, $0, 0x10010080
# n=5(将寄存器0的值加5之后放到寄存器s0里面，注意：$0 表示一个始终存在的寄存器zero，它的值就是0)
addiu $s0, $0, 5
# 将寄存器s0的值，写到寄存器sp所指向的内存地址（注意：寄存器sp是栈指针寄存器（是操作系统固有的），sw指令就是将寄存器的值写到内存）
sw $s0, 0($sp)
# 压栈（将栈指针寄存器sp的值减4（注意：这个操作的意义其实就是将栈指针指向下一个值，就是压栈，先入后出））
addiu $sp, $sp, -4

# 跳转到FACT指令块（注意：下面的nop是跳转指令的规范，跳转必须加这个）
jal FACT
nop
j END
nop

# FACT指令块（其实就是函数块）
FACT:
# 将寄存器ra的值，写到寄存器sp所指向的内存地址
# 注意：寄存器sp是栈指针寄存器（是操作系统固有的），sw指令就是将寄存器的值写到内存
# 注意：ra是pc指针寄存器（只要 jal FACT 跳转指令一执行，就会将下一行要执行的指针存到了ra寄存器）
sw $ra, 0($sp)
# 压栈（将栈指针寄存器sp的值减4（注意：这个操作的意义其实就是将栈指针指向下一个值，就是压栈，先入后出））
addiu $sp, $sp, -4
# 读取入参（（将栈指针sp读出来加8，获取到结果再将结果放到寄存器s0里面，为什么要加8是因为上面压了2次栈））
lw $s0, 8($sp)
# 压栈返回值（将寄存器s0的值，写到寄存器sp所指向的内存地址（注意：寄存器sp是栈指针寄存器（是操作系统固有的），sw指令就是将寄存器的值写到内存））
sw $0, 0($sp)
# 压栈（将栈指针寄存器sp的值减4（注意：这个操作的意义其实就是将栈指针指向下一个值，就是压栈，先入后出））
addiu $sp, $sp, -4
# 递归base条件if (n == 0) { return 1}
# 如果寄存器s0的值和寄存器0的值相等，则往下走，否则走RECURSION指令块（注意：$0 表示一个始终存在的寄存器zero，它的值就是0）
bne $s0, $0, RECURSION
nop
# 读取放回地址（将栈指针sp读出来加8，获取到结果再将结果放到寄存器ti里面）
lw $t1, 8($sp)
# 出栈 返回值和地址(将寄存器sp的值加8之后放到寄存器sp里面)
addiu $sp, $sp, 8
# 压栈返回值(将寄存器zero的值加1之后放到寄存器sp里面,注意：$zero 表示一个始终存在的寄存器zero，它的值就是0)
addiu $s0, $zero, 1
# 压栈返回值（将寄存器s0的值，写到寄存器sp所指向的内存地址（注意：寄存器sp是栈指针寄存器（是操作系统固有的），sw指令就是将寄存器的值写到内存））
sw $s0, 0($sp)
addiu $sp, $sp, -4

# 跳转地址
jr $t1
nop

# RECURSION 指令块 return fact(n - 1) * n
RECURSION :
# 压栈递归参数（注意：其实就是 n - 1）
addiu $s1, $s0, -1
sw $s1, 0($sp)
addiu $sp, $sp, -4
# 跳转到FACT指令块，进行递归
jal FACT
nop

# 现在战队样子:  当前函数体的参数 <- 返回地址 <- 返回值 <- 子函数的参数 <- 子函数的返回值 <- 当前SP
# 当前函数体的参数
lw $s0, 20($sp)
# 子函数的返回值
lw $s1, 4($sp)
# 返回地址
lw $t1, 16($sp)
# 将寄存器s1的值与寄存器s0的值相乘
mult $s1, $s0
# 从寄存器lo里面将相乘的结果取出来放到寄存器s2里面（注意：相乘的高位结果找hi寄存器里面，相乘的底位在寄存器lo里面）
mflo $s2

# 出栈
addiu $sp, $sp, 16
# 返回值压栈
sw $s2, 0($sp)
addiu $sp, $sp, -4

# 返回
jr $t1
nop

END:
```